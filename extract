#! /usr/local/bin/python

import argparse
import collections
from datetime import datetime
from decimal import Decimal
import itertools
import psycopg2
import re
import unicodecsv

desc = 'Extract the transaction section of a Shoeboxed CSV export.'
ap = argparse.ArgumentParser(description=desc)
ap.add_argument('--version', action='version', version='SettleUp 0.1')

desc = 'The source CSV file. If omitted will read from STDIN.'
ap.add_argument('source_csv', metavar='FILE', help=desc)

args = ap.parse_args()

# assume that the transaction section header is a record having at least:
#   Date, Store, Total (USD), Payment Type, Categories, Link
# if there is no such record then the export format has changed
# and we don't have the requisite fields to proceed
def is_transaction_prefix(record):
    mark = {'Date', 'Store', 'Total (USD)', 'Payment Type', 'Categories', 'Link'}
    return set(record).issuperset(mark)

# the transaction section is followed by a blank record
def is_transaction_suffix(record):
    return len([f for f in record if f]) == 0

class ShoeboxedCSVReader(object):
    def __init__(self, f):
        self.reader = itertools.takewhile(lambda x: not is_transaction_suffix(x),
                      itertools.dropwhile(lambda x: not is_transaction_prefix(x),
                      unicodecsv.reader(f)))

        # we want to fail here if no records match is_transaction_prefix
        self.header = self.reader.next()

    def __iter__(self): return iter(self.reader)

# compile regex for credit card
card = re.compile(r'Card \(([0-9]{4})\)')

# create named tuple which is all of the target fields
Transaction = collections.namedtuple('Transaction', [
    'amount', 'merchant_name', 'cc', 'owner', 'remote_id', 'transaction_date'
])

def check_label(labels):
    categories = set(record['Categories'])
    intersection = categories.intersection(labels)
    if len(intersection) == 1: return tuple(intersection)[0]
    else: raise ValueError('Incorrect labels')

def record_to_transaction(record):
    for field in ['Total (USD)', 'Link']:
        if not record[field]: raise ValueError('Missing required value')

    if not record['Date']:
        transaction_date = None
    else:
        transaction_date = datetime.strptime(record['Date'], '%b %d, %Y').date()

    result = card.match(record['Payment Type'])
    if result:
        cc = result.group(1)
    else:
        payer_labels = {'By Melanie', 'By Kaiting'}
        payer = check_label(payer_labels)
        if payer == 'By Melanie': cc = 'MELA'
        else: cc = 'KMAN'

    owner_map = { 'For Both of Us': None,
      'For Melanie': 'Melanie Plageman',
      'For Kaiting': 'Kaiting Chen' }
    owner = owner_map[check_label(set(owner_map.keys()))]

    return Transaction(
        merchant_name = record['Store'] or None,
        cc = cc,
        amount = Decimal(record['Total (USD)']),
        # remote_id is the last path component of Link
        remote_id = record['Link'].split('/')[-1],
        owner = owner,
        transaction_date = transaction_date
    )

with open(args.source_csv, 'r') as f:
    reader = ShoeboxedCSVReader(f)

    rawcsv = [ dict(zip(reader.header, record)) for record in reader ]

    for record in rawcsv:
        record['Categories'] = record['Categories'].split(', ')

    relcsv = [ record for record in rawcsv if 'NYC' not in record['Categories'] ]

    conn = psycopg2.connect(
            host='ec2-107-22-187-89.compute-1.amazonaws.com',
            database='dbtrl58pa0ipp6',
            user='rpvalfmhbpbsml')
    cursor = conn.cursor()

    for record in relcsv:
        cursor.execute(
            'INSERT INTO transactions (merchant_name, cc, amount, remote_id, owner, transaction_date) VALUES (%s, %s, %s, %s, %s, %s);',
            (t.merchant_name, t.cc, t.amount, t.remote_id, t.owner, t.transaction_date)
        )

    conn.commit()
    conn.close()
